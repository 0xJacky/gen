package template

const HeaderTmpl = `
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package {{.}}

import(
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/schema"

	"gorm.io/gen/field"
	"gorm.io/gen/helper"
)
`

const FuncTmpl = `
/*
{{.Doc}}*/
func ({{.S}} {{.MethodStruct}}){{.MethodName}}({{range $index,$params:=.Params}}{{if ne $index 0}},{{end}}{{$params.Name}} {{if ne $params.Package ""}}{{$params.Package}}.{{end}}{{$params.Type}}{{end}})({{range $index,$params:=.Result}}{{if ne $index 0}},{{end}}{{$params.Name}} {{if $params.IsArray}}[]{{end}}{{if $params.IsPointer}}*{{end}}{{if ne $params.Package ""}}{{$params.Package}}.{{end}}{{$params.Type}}{{end}}){
	{{if .HasSqlData}}params := map[string]interface{}{ {{range $index,$data:=.SqlData}}
		"{{$data}}":{{$data}},{{end}}
	}
	{{end}}
	{{if eq .Table "_"}}table:={{.S}}.UnderlyingDB().Statement.Table{{end}}

	var generateSQL string
	{{range $line:=.SqlTmplList}}{{$line}}
	{{end}}

	{{if .HasNeedNewResult}}result =new({{if ne .ResultData.Package ""}}{{.ResultData.Package}}.{{end}}{{.ResultData.Type}}){{end}}
	{{.ExecuteResult}} = {{.S}}.UnderlyingDB().{{.GormOption}}(generateSQL{{if .HasSqlData}},params{{end}}){{if not .ResultData.IsNull}}.Find({{if .HasGotPoint}}&{{end}}{{.ResultData.Name}}){{end}}.Error
	return
}

`

const BaseStruct = `
type {{.NewStructName}} struct {
	gen.DO

	{{range $p :=.Members}}{{$p.Name}}  field.{{$p.NewType}}
	{{end}}
}

func New{{.StructName}}(db *gorm.DB) *{{.NewStructName}} {
	_{{.NewStructName}} := new({{.NewStructName}})

	_{{.NewStructName}}.UseDB(db)
	_{{.NewStructName}}.UseModel({{.StructInfo.Package}}.{{.StructInfo.Type}}{})

	{{if .HasMember}}tableName := _{{.NewStructName}}.TableName(){{end}}
	{{range $p :=.Members}} _{{$.NewStructName}}.{{$p.Name}} = field.New{{$p.NewType}}(tableName, "{{$p.ColumnName}}")
	{{end}}
	
	return _{{.NewStructName}}
}

`

const BaseGormFunc = `
func ({{.S}} {{.NewStructName}}) Debug() *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Debug().(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Hints(hs ...gen.Hint) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Hints(hs...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Not(conds ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Not(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Or(conds ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Or(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Select(conds ...field.Expr) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Select(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Where(conds ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Where(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Order(conds ...field.Expr) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Order(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Distinct(cols ...field.Expr) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Distinct(cols...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Omit(cols ...field.Expr) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Omit(cols...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Join(table schema.Tabler, on ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Join(table, on...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) LeftJoin(table schema.Tabler, on ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.LeftJoin(table, on...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) RightJoin(table schema.Tabler, on ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.RightJoin(table, on...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Group(col field.Expr) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Group(col).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Having(conds ...gen.Condition) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Having(conds...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Limit(limit int) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Limit(limit).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Offset(offset int) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Offset(offset).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Scopes(funcs ...func(*{{.NewStructName}}) *{{.NewStructName}}) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Scopes(funcs...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Unscoped() *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Unscoped().(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Create(value *{{.StructInfo.Package}}.{{.StructInfo.Type}}) error {
	return {{.S}}.DO.Create(value)
}

func ({{.S}} {{.NewStructName}}) CreateInBatches(values []*{{.StructInfo.Package}}.{{.StructInfo.Type}}, batchSize int) error {
	return {{.S}}.DO.CreateInBatches(values, batchSize)
}

func ({{.S}} {{.NewStructName}}) Save(value *{{.StructInfo.Package}}.{{.StructInfo.Type}}) error {
	return {{.S}}.DO.Save(value)
}

func ({{.S}} {{.NewStructName}}) First(conds ...field.Expr) (*{{.StructInfo.Package}}.{{.StructInfo.Type}}, error) {
	result := new({{.StructInfo.Package}}.{{.StructInfo.Type}})
	if err := {{.S}}.DO.First(result, conds...); err != nil {
		return nil, err
	}
	return result, nil
}

func ({{.S}} {{.NewStructName}}) Last(conds ...field.Expr) (*{{.StructInfo.Package}}.{{.StructInfo.Type}}, error) {
	result := new({{.StructInfo.Package}}.{{.StructInfo.Type}})
	if err := {{.S}}.DO.Last(result, conds...); err != nil {
		return nil, err
	}
	return result, nil
}

func ({{.S}} {{.NewStructName}}) Take(conds ...field.Expr) (*{{.StructInfo.Package}}.{{.StructInfo.Type}}, error) {
	result := new({{.StructInfo.Package}}.{{.StructInfo.Type}})
	if err := {{.S}}.DO.Take(result, conds...); err != nil {
		return nil, err
	}
	return result, nil
}

func ({{.S}} {{.NewStructName}}) Find(conds ...field.Expr) (result []*{{.StructInfo.Package}}.{{.StructInfo.Type}},err error) {
	return result, {{.S}}.DO.Find(&result, conds...)
}

func ({{.S}} {{.NewStructName}}) FindInBatches(batchSize int, fc func(tx *{{.NewStructName}}, batch int) error) (result []*{{.StructInfo.Package}}.{{.StructInfo.Type}},err error) {
	return result, {{.S}}.DO.FindInBatches(&result, batchSize, func(tx gen.Dao, batch int) error {
		newItem := {{.S}}
		newItem.DO = *tx.(*gen.DO)
		return fc(&newItem, batch)
	})
}

func ({{.S}} {{.NewStructName}}) FirstOrInit(conds ...field.Expr) (result []*{{.StructInfo.Package}}.{{.StructInfo.Type}},err error) {
	return result, {{.S}}.DO.FirstOrInit(&result, conds...)
}

func ({{.S}} {{.NewStructName}}) FirstOrCreate(conds ...field.Expr) (result []*{{.StructInfo.Package}}.{{.StructInfo.Type}},err error) {
	return result, {{.S}}.DO.FirstOrCreate(&result, conds...)
}

func ({{.S}} {{.NewStructName}}) FindByPage(offset int, limit int) (result []*{{.StructInfo.Package}}.{{.StructInfo.Type}}, count int64, err error) {
	err = {{.S}}.DO.Count(&count)
	if err != nil {
		return
	}
	err = {{.S}}.DO.Offset(offset).Limit(limit).Find(&result)
	return
}

func ({{.S}} {{.NewStructName}}) Update(col field.Expr, value interface{}) error {
	return {{.S}}.DO.Update(col, value)
}

func ({{.S}} {{.NewStructName}}) Updates(values interface{}) error {
	return {{.S}}.DO.Updates(values)
}

func ({{.S}} {{.NewStructName}}) UpdateColumn(col field.Expr, value interface{}) error {
	return {{.S}}.DO.UpdateColumn(col, value)
}

func ({{.S}} {{.NewStructName}}) UpdateColumns(values interface{}) error {
	return {{.S}}.DO.UpdateColumns(values)
}

func ({{.S}} {{.NewStructName}}) Delete(conds ...field.Expr) error {
	result := new({{.StructInfo.Package}}.{{.StructInfo.Type}})
	return {{.S}}.DO.Delete(result, conds...)
}

func ({{.S}} {{.NewStructName}}) Count(count *int64) error {
	return {{.S}}.DO.Count(count)
}

func ({{.S}} {{.NewStructName}}) Row() *sql.Row {
	return {{.S}}.DO.Row()
}

func ({{.S}} {{.NewStructName}}) Rows() (*sql.Rows, error) {
	return {{.S}}.DO.Rows()
}

func ({{.S}} {{.NewStructName}}) Scan(dest interface{}) error {
	return {{.S}}.DO.Scan(dest)
}

func ({{.S}} {{.NewStructName}}) Pluck(col field.Expr, dest interface{}) error {
	return {{.S}}.DO.Pluck(col, dest)
}

func ({{.S}} {{.NewStructName}}) ScanRows(rows *sql.Rows, dest interface{}) error {
	return {{.S}}.DO.ScanRows(rows, dest)
}

func ({{.S}} {{.NewStructName}}) Transaction(fc func(tx *{{.NewStructName}}) error, opts ...*sql.TxOptions) error {
	return {{.S}}.DO.Transaction(func(tx gen.Dao) error {
		newItem := p
		newItem.DO = *tx.(*gen.DO)
		return fc(&newItem)
	}, opts...)
}

func ({{.S}} {{.NewStructName}}) Begin(opts ...*sql.TxOptions) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Begin(opts...).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) Commit() *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Commit().(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) RollBack() *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.Commit().(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) SavePoint(name string) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.SavePoint(name).(*gen.DO)
	return &{{.S}}
}

func ({{.S}} {{.NewStructName}}) RollBackTo(name string) *{{.NewStructName}} {
	{{.S}}.DO = *{{.S}}.DO.RollBackTo(name).(*gen.DO)
	return &{{.S}}
}
`

const UseTmpl = `
type DB struct{
	db *gorm.DB

	{{range $name,$d :=.Data}}{{$d.StructName}} *{{$d.NewStructName}}
	{{end}}
}

func (d *DB) Transaction(fc func(db *DB) error, opts ...*sql.TxOptions) error {
	return d.db.Transaction(func(tx *gorm.DB) error { return fc(d.withTx(tx)) }, opts...)
}

func (d *DB) Begin(opts ...*sql.TxOptions) *DB {
	d.db = d.db.Begin(opts...)
	return d
}

func (d *DB) Commit() *DB {
	d.db = d.db.Commit()
	return d
}

func (d *DB) Rollback() *DB {
	d.db = d.db.Rollback()
	return d
}

func (d *DB) SavePoint(name string) *DB {
	d.db = d.db.SavePoint(name)
	return d
}

func (d *DB) RollbackTo(name string) *DB {
	d.db = d.db.RollbackTo(name)
	return d
}

func (d *DB) withTx(tx *gorm.DB) *DB {
	newDB := *d
	newDB.db = tx
	return &newDB
}

func Use(db *gorm.DB) *DB {
	return &DB{
		db: db,
		{{range $name,$d :=.Data}}{{$d.StructName}}: New{{$d.StructName}}(db),
		{{end}}
	}
}
`

// ModelTemplate used as a variable because it cannot load template file after packed, params still can pass file
const ModelTemplate = `
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
package {{.StructInfo.Package}}

import "time"

const TableName{{.StructName}} = "{{.TableName}}"

// {{.TableName}}
type {{.StructName}} struct {
    {{range .Members}}
    {{.Name}} {{.ModelType}} ` + "`json:\"{{.ColumnName}}\" gorm:\"column:{{.ColumnName}}\"` // {{.ColumnComment}}" +
	`{{end}}
}

// TableName .
func (*{{.StructName}}) TableName() string {
    return TableName{{.StructName}}
}
`
